<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-05-07 ter 21:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title><code>cl-jackc</code>'s Grammar Language</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Lucas Vieira" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<h1 class="title"><code>cl-jackc</code>'s Grammar Language</h1><p><i>Written in  by Lucas Vieira<br/><a href="mailto:lucasvieira@protonmail.com">lucasvieira@protonmail.com</a></i></p>
</div>
<div id="content">
<h1 class="title"><code>cl-jackc</code>'s Grammar Language</h1>
<div class="org-center">
<p>
<i>ABSTRACT</i>
</p>
</div>

<p>
<code>cl-jackc</code><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> is an implementation of a compiler for the Jack
programming language. It uses its own grammar engine for \(LL(1)\)
grammars, written from scratch in Common Lisp. This article outlines
the domain-specific language for specifying grammar rules, its key
points, and my experience on building the matching engine which
interprets the grammar language.
</p>


<div id="outline-container-org8558dde" class="outline-2">
<h2 id="org8558dde"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Building programming languages is often an arduous, but fun task. Some
of the work lies on the designing of the language and its syntactical
elements <i>per se</i>. The rest of the work lies on building the tools
to make the language work, namely the compiler toolchain. In this
article, I discuss a fragment of the compiler toolchain for the Jack
programming language, one of the projects proposed by Nisan and
Schocken (2008) <a class='org-ref-reference' href="#nand2tetris">nand2tetris</a>, which is the parser for the syntax
analysis of the Jack programming language.
</p>

<p>
The related book provides a very clear grammar for Jack, and so the
job of the reader is to simply write a compiler for the language, in
two different projects<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>. Here I show some of my strategies to
build the first of the projects, while having zero experience on
writing compilers.
</p>

<p>
Nisan and Schocken (2008) <a class='org-ref-reference' href="#nand2tetris">nand2tetris</a> provide a blueprint for the
project software architecture in the Java language, so that the job of
the reader is sped up. This model, however, obeys certain principles
of object-oriented design which describe a very rigid software
architecture. Due to influence of Abelson and Sussman (1996)
<a class='org-ref-reference' href="#sicp">sicp</a>, when primarily thinking of what to do, I did not view the
compiler architecture as a rigid hierarchy of software modules,
interacting with each other. While the modularization is still
maintained, mostly for file organization and for keeping some degree
of similarity with the proposed implementation, the syntax analyzer
was primarily designed as layers of software comprising of certain
abstractions, as if each of these layers were <i>domain-specific
languages</i> themselves that could be used to build upper abstraction
layers.
</p>

<p>
This approach led me to build a de-facto <i>domain-specific language</i>
to represent the grammar of the Jack programming language in the
topmost level. It also acquired the intended effect of having an
underlying robust, simple and well-organized codebase. The formalisms
and operation of this topmost grammar language are detailed as follows.
</p>
</div>
</div>

<div id="outline-container-org84c67c8" class="outline-2">
<h2 id="org84c67c8"><span class="section-number-2">2</span> Grammars</h2>
<div class="outline-text-2" id="text-2">
<p>
Vieira (2006)<a class='org-ref-reference' href="#newton2006">newton2006</a> states that a grammar is a formalism
originally conceived for defining formal languages. The fundamental
elements of grammars are the <i>rules</i>, which demonstrate how to generate
a language's <i>words</i>.
</p>

<p>
Let there be a grammar \(G\), which is a tuple \((V, \Sigma, R, P)\)
where:
</p>

<ul class="org-ul">
<li>\(V\) is a finite set of all language <i>variables</i>;</li>
<li>\(\Sigma\) is the language's alphabet, where \(V \cap \Sigma =
  \varnothing\);</li>
<li>\(R\) is a finite set comprised of ordered pairs known as <i>rules</i>, and</li>
<li>\(P \in V\) is a variable known as a starting point.</li>
</ul>

<p>
A grammar \(G\) is valid when it is possible to generate <i>sentential
forms</i> from its rules, such that these <i>forms</i> are not populated by any
<i>variable</i>, but only with <i>terminals</i> (\(\alpha \in \Sigma\)). These special
<i>forms</i> are often called <i>words</i>.The set of all <i>words</i> generated by a
grammar is called \(L(G)\), or <i>language of \(G\)</i>.
</p>

<p>
It is said that a <i>word</i> \(\omega\) belongs to \(L(G)\) if, and only if,
\(\omega\) can be derived in \(n\) steps from \(G\)'s <i>rules</i>.
</p>

<p>
The <i>rules</i> of a grammar, as already stated, are ordered pairs. The
first element of the pair states <i>what should be replaced</i>, and the
second element states <i>what is the replacement</i>. For example, consider
the following rules.
</p>

\begin{align}
A &\rightarrow aA\\
A &\rightarrow B\\
B &\rightarrow \lambda
\end{align}

<p>
These <i>rules</i> belong to a certain type of grammar which will be crucial
to the incoming object of discussion. Given a starting point \(A\), as
per Rule 1, it is possible to infer that this language is capable of
generating <i>words</i> with an arbitrary number of "\(a\)" <i>terminals</i>, plus a
dangling "\(A\)" variable at the end. After that, \(A\) can be transformed
into \(B\) (Rule 2), and \(B\) is then transformed into the <i>empty word</i>
\(\lambda\) (Rule 3), which acts as the stopping point for grammar
generation, leaving only a <i>word</i> comprised of <i>terminals</i>. This language
may also be represented as \(\{a\}^{*}\).
</p>

<p>
The previous example is interesting because the left-hand part of all
rules is comprised only of <i>variables</i>. This means that, for any given
variable which may appear in a <i>sentential form</i>, that single variable
must have one or more corresponding rules which replace
it. Furthermore, it is only necessary to find and replace <i>variables</i> in
the <i>sentential form</i>, and never to analyze the disposition of
<i>terminals</i>, since there are no <i>rules</i> requiring this procedure.
</p>

<p>
A grammar for the Jack language <a class='org-ref-reference' href="#nand2tetris">nand2tetris</a> is written using
exactly this model. Each of the <i>rules</i> are a simple pair, where the
first component is a <i>variable</i> which may appear anywhere, and so it can
be transformed by another given rule of the grammar. Using this simple
theorem, it is possible to write an application which takes a <i>source
code</i> and parses it, so that this analysis indicates whether the <i>code</i>
is a <i>word</i> of the Jack <i>language</i> or not.
</p>
</div>
</div>

<div id="outline-container-org26544bd" class="outline-2">
<h2 id="org26544bd"><span class="section-number-2">3</span> Compiler's grammar syntax</h2>
<div class="outline-text-2" id="text-3">
<p>
The compiler's grammar language is written using s-expressions, since
the application itself is written in Common Lisp. The chosen language
provides powerful abstractions for dealing with lists. The grammar is
written as an abstract syntax tree, so that Lisp makes it easier to
traverse each rule.
</p>

<p>
A grammar is a list of rules. Each rule is a pair of two elements: a
<i>name</i> and a <i>match</i>. There must be at least one rule enumerating
<i>terminals</i>, which are expected textual elements.
</p>

<p>
<i>Names</i> are Lisp keywords<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>, and therefore are prepended with a
double colon, so that they are agnostic to the namespace<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> they're
in.
</p>

<p>
Figure <a href="#orgb30aada">1</a> is a transcribed fragment of a single rule
for matching with a class structure of the Jack programming
language. The rule is provided for illustrative purposes.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Rule for matching a class definition in the Jack language.</label><pre class="src src-lisp" id="orgb30aada">(<span class="org-builtin">:class</span>   ((<span class="org-builtin">:keyword</span> <span class="org-string">"class"</span>) <span class="org-builtin">:class-name</span> (<span class="org-builtin">:symbol</span> <span class="org-string">"{"</span>)
           (<span class="org-builtin">:many</span> <span class="org-builtin">:class-var-dec</span>)
           (<span class="org-builtin">:many</span> <span class="org-builtin">:subroutine-dec</span>)
           (<span class="org-builtin">:symbol</span> <span class="org-string">"}"</span>)))
</pre>
</div>
<p>
The <i>match</i> component of a rule is, in itself, a list, and so it carries
its own meaning. The <i>match</i> may be populated by other <i>keyword names</i>,
<i>quantified rules</i>, <i>precise rules</i> and <i>exact-matches</i>, which must also be
specified in the grammar itself.
</p>

<p>
Any valid Jack source code begins with a class definition, and so
<code>:CLASS</code> corresponds to the starting point for the matching engine. The
code snippet at Figure <a href="#orgb30aada">1</a> offers a way to expect a class
definition in the Jack programming language (adapted from Nisan and
Schocken (2005) <a class='org-ref-reference' href="#nand2tetris">nand2tetris</a>). To recognize a class, the grammar
expects the match of a <i>precise</i> pattern, in the following order:
</p>

<ul class="org-ul">
<li>An exact match with the keyword "<code>class</code>";</li>
<li>The class's name, whatever it may be;</li>
<li>An exact match with the symbol <code>{</code>;</li>
<li>Zero or more variable declarations, whatever it may be;</li>
<li>Zero or more subroutine declarations, whatever it may be;</li>
<li>An exact match with the symbol <code>}</code>.</li>
</ul>

<p>
The matching engine works recursively, as it is suggested from the
<i>wishful thinking</i> approach (Abelson and Sussman (1996) <a class='org-ref-reference' href="#sicp">sicp</a>).
These operations (as well as the <i>match</i> portion of the rule itself)
require better clarification of their underlying structure.
</p>

<p>
A valid grammar, when written in the grammar language, is comprised of
atomic rules, which enumerate most <i>primitives</i>, and of compound rules,
which enumerate a single kind of <i>primitive</i> and some <i>means of
combination</i> for the rest of the rules.
</p>
</div>

<div id="outline-container-org10f7211" class="outline-3">
<h3 id="org10f7211">Atomic rules</h3>
<div class="outline-text-3" id="text-org10f7211">
<p>
A rule is atomic if it is comprised of a single keyword. These rules
are of the same type of the rule <i>names</i>, as they are meant to be
replaced by the body of another rule by the matching engine.
</p>

<p>
There are also built-in atomic rules which do not need to appear on
the grammar, since they are primitive to the matching engine, and so
they are enumerated as follows:
</p>

<ul class="org-ul">
<li><code>:IDENTIFIER</code>: Any name which does not start with a letter. Breaks
before a <code>:SYMBOL</code> or any whitespace.</li>
<li><code>:STRING-CONSTANT</code>: Any text surrounded with quotes. Cannot have any
line breaks.</li>
<li><code>:INTEGER-CONSTANT</code>: Any text comprised only of numbers and no
<code>:SYMBOL</code> terminals.</li>
<li><i>Terminals</i>: Any text. The text can be written as a string constant
for Lisp.</li>
</ul>

<p>
Since matching these rules require knowledge of what a <code>:SYMBOL</code> and a
<code>:KEYWORD</code> are, these rules must always be defined for any grammar. They
can also be compared to the alphabet \(\Sigma\) of a formal grammar
(Vieira (2006) <a class='org-ref-reference' href="#newton2006">newton2006</a>). This aspect will be discussed later,
in greater detail.
</p>

<p>
In a rule such as <code>(:KEYWORD "class")</code>, the element <code>"class"</code> is a
<i>terminal</i>, as it is raw text expected to be at the matching source code
position. However, the rule as a whole is not atomic, as will be
further discussed in the following subsection.
</p>
</div>
</div>

<div id="outline-container-org0f70c1a" class="outline-3">
<h3 id="org0f70c1a">Compound rules</h3>
<div class="outline-text-3" id="text-org0f70c1a">
<p>
Any list in the <i>match</i> element is a compound rule. Since the <i>match</i>
element itself is a list comprised of several sub-rules, it is also
considered as a compound rule, in accordance to one of the following
archetypes.
</p>
</div>

<div id="outline-container-orgcd588dc" class="outline-4">
<h4 id="orgcd588dc">Quantified rules</h4>
<div class="outline-text-4" id="text-orgcd588dc">
<p>
A <i>compound rule</i> is a <i>quantified rule</i> when its first element is a
quantifier keyword. The quantifier changes the matching engine context
for the elements it encloses, following the meaning of the quantifier
keywords:
</p>

<ul class="org-ul">
<li><code>:OR</code>: A disjunction of rules. Attempts to match, in order, each of
the sub-rules it encloses. Stops when one of the rules is matched,
and does not check for the remaining rules.</li>
<li><code>:MAYBE</code>: Attempts to sequentially match the group of all enclosed
sub-rules, but the matching is optional; failure on the matching
process does not fail the rest of the grammar match (<i>zero-or-one</i>).</li>
<li><code>:MANY</code>: Attempts to match the group of all enclosed sub-rules
exhaustively, and keeps collecting the matching results until the
repeating match fails (<i>zero-or-more</i>).</li>
</ul>

<p>
A <i>quantified rule</i> such as <code>(:many :identifier)</code>, for example, will keep
collecting identifiers until there are no more identifiers to be
collected. When matching an identifier fails, then all previously
matched identifiers are collected. If no identifier was matched, the
match results in a neutral value, but never fails.
</p>

<p>
A rule such as <code>(:maybe :identifier :integer-constant)</code> will attempt to
match an identifier and then an integer constant. If any of those
structures are not matched, then the match results in a neutral
value, but never fails.
</p>

<p>
The rule <code>(:or :identifier :integer-constant)</code> attempts to match an
identifier. If the identifier is not found, it attempts to match an
integer constant. If the integer constant is also not found, then the
match results in failure.
</p>
</div>
</div>

<div id="outline-container-org5edc4c0" class="outline-4">
<h4 id="org5edc4c0">Exact-matches</h4>
<div class="outline-text-4" id="text-org5edc4c0">
<p>
A <i>compound rule</i> is an <i>exact-match rule</i> when comprised of two elements,
where its first element is an existing rule in the grammar, and the
second element is an expected <i>terminal</i>.
</p>

<p>
The <i>terminal</i> element of an <i>exact-match rule</i> must belong to a
disjunctively-quantified rule, where each element of the disjunction
is a <i>terminal</i> text as well. This associated, disjunctive rule is not
supposed to be used in matching time, though it is important for
grammar verification.
</p>

<p>
Any <i>exact-match rule</i> which uses a non-existing disjunctive rule, or
uses a <i>terminal</i> which does not belong to the associated disjunctive
rule, is considered to be syntactically incorrect.
</p>

<p>
A rule such as <code>(:KEYWORD "class")</code> is a well-defined <i>exact-match rule</i>,
if and only if the grammar contains a rule as exemplified in Figure
<a href="#orga93985c">2</a>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Example of a supporting rule for an <i>exact-match rule</i>.</label><pre class="src src-lisp" id="orga93985c">(<span class="org-builtin">:KEYWORD</span>   ((<span class="org-builtin">:OR</span> <span class="org-string">"class"</span> <span class="org-string">"constructor"</span> <span class="org-string">"function"</span> ...)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd33089" class="outline-4">
<h4 id="orgdd33089">Precise rules</h4>
<div class="outline-text-4" id="text-orgdd33089">
<p>
A <i>precise rule</i> is the commonest type of rule, as the <i>match</i>
element of a rule definition often falls into it. Moreover, any
non-disjunctively quantified rule ends up degenerating into a <i>precise
rule</i>, only changing the context where such <i>precise rule</i> fails.
</p>

<p>
Any part of a <i>match</i> element of a rule, which is also <i>compound</i>, but
does not fall into the previous categories, is a <i>precise rule</i>. In
other words, such rules are surrounded by parenthesis, but their first
element is not a quantifier, and they also do not fit the <i>exact-match
rule</i> specification.
</p>

<p>
These <i>compound rules</i> are basically enclosings for sub-rules which must
"travel" as a group, and so all of their sub-rules must always
match. Since a rule definition enumerates how it works, it is advised
that any <i>match</i> portion of a rule definition should be a <i>precise rule</i>
itself.
</p>

<p>
A rule such as <code>(:IDENTIFIER (:SYMBOL "=") :INTEGER-CONSTANT)</code> is a
valid <i>precise rule</i>. The grammar expects three sub-rules to be matched
sequentially. Should any of them fail, then the whole group fails.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbdedd2f" class="outline-3">
<h3 id="orgbdedd2f">Obligatory rules</h3>
<div class="outline-text-3" id="text-orgbdedd2f">
<p>
As the matching engine was implemented, it was discovered that the
structure needed to assume that certain rules were to be
always expected. These obligatory rules, however, are lexical elements
which are common to most languages.
</p>

<ul class="org-ul">
<li><code>:KEYWORD</code>: A disjunctively-quantified rule enumerating all text
<i>terminals</i> of the language which are <i>language keywords</i>.</li>
<li><code>:SYMBOL</code>: A disjunctively-quantified rule enumerationg all text
<i>terminals</i> of the language which are <i>language symbols</i>.</li>
</ul>

<p>
Keywords and symbols enumerate nothing less than the alphabet \(\Sigma\)
of a language, and therefore act as the primary <i>terminals</i> for any
other grammar rules.
</p>

<p>
Figure <a href="#org02004c0">3</a> is a snippet showing the Jack language's
keywords and symbols, based on the language's grammar specification
(Nisan and Schocken (2008), pp. 208-209 <a class='org-ref-reference' href="#nand2tetris">nand2tetris</a>).
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Keywords and symbols as defined for the Jack language.</label><pre class="src src-lisp" id="org02004c0">(<span class="org-builtin">:keyword</span>  ((<span class="org-builtin">:or</span> <span class="org-string">"class"</span> <span class="org-string">"constructor"</span> <span class="org-string">"function"</span>
                 <span class="org-string">"method"</span> <span class="org-string">"field"</span> <span class="org-string">"static"</span> <span class="org-string">"var"</span>
                 <span class="org-string">"int"</span> <span class="org-string">"char"</span> <span class="org-string">"boolean"</span> <span class="org-string">"void"</span>
                 <span class="org-string">"true"</span> <span class="org-string">"false"</span> <span class="org-string">"null"</span> <span class="org-string">"this"</span> <span class="org-string">"let"</span>
                 <span class="org-string">"do"</span> <span class="org-string">"if"</span> <span class="org-string">"else"</span> <span class="org-string">"while"</span> <span class="org-string">"return"</span>)))

(<span class="org-builtin">:symbol</span>   ((<span class="org-builtin">:or</span> <span class="org-string">"{"</span> <span class="org-string">"}"</span> <span class="org-string">"("</span> <span class="org-string">")"</span> <span class="org-string">"["</span> <span class="org-string">"]"</span> <span class="org-string">"."</span> <span class="org-string">","</span>
                 <span class="org-string">";"</span> <span class="org-string">"+"</span> <span class="org-string">"-"</span> <span class="org-string">"*"</span> <span class="org-string">"/"</span> <span class="org-string">"&amp;"</span> <span class="org-string">"|"</span> <span class="org-string">"&lt;"</span>
                 <span class="org-string">"&gt;"</span> <span class="org-string">"="</span> <span class="org-string">"~"</span>)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb93490a" class="outline-3">
<h3 id="orgb93490a">Code commentary</h3>
<div class="outline-text-3" id="text-orgb93490a">
<p>
Comments in any language are often surrounded by two tokens, which are
equivalent to text <i>terminals</i>. Comment detection, however, is not
considered part of the grammar rules, as they are treated as a
responsibility of the tokenizer.
</p>

<p>
The matching engine's topmost structure is responsible for comparing
tokens which are already assumed to be valid, and comment delimiters
(plus the contents of any comment) are not supposed to be valid
tokens. For that reason, the comments are defined using an outside
structure, a list of pairs which enumerate the tokens enclosing any
comments<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>.
</p>

<p>
Let us take the Jack programming language as an example, as the
matching engine was primarily built for it. A pair, in Lisp notation,
such as <code>("/*" . "*/")</code> shows that there may be comments in the source
file, which begin with the token <code>/*</code> and end with the token <code>*/</code>. And
so, the matching engine's head, which is supposed to point at every
read character, will simply skip the undesired characters &#x2013; both the
comment tokens and the text inbetween.
</p>

<p>
As for comments which end at a line break, a simple definition such as
<code>("//")</code> suffices. This definition can also be written in the form
<code>("//" . NIL)</code>, and so it implies that, when an end-of-comment delimiter
is not informed, then that delimiter must be a <code>#\Newline</code> character.
</p>
</div>
</div>
</div>

<div id="outline-container-org84d7d58" class="outline-2">
<h2 id="org84d7d58"><span class="section-number-2">4</span> Rule composition</h2>
<div class="outline-text-2" id="text-4">
<p>
The grammar language fundamentals have been outlined. <i>Terminals</i>,
<i>exact-matches</i> and <i>built-in rules</i> act as primitives, while other
<i>compound rules</i> act as means of combination. At this point it is
important to discuss the language's <i>means of abstraction</i>.
</p>

<p>
Abstraction implies the building of structures which would allow the
creation of the <i>rules</i> themselves. Figure <a href="#orgb30aada">1</a> already hints
at what is possible to make of the grammar language. For a better
understanding, we should take a simpler example, as described in
Figure <a href="#org361c76f">4</a>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Rule example for matching a variable declaration.</label><pre class="src src-lisp" id="org361c76f">(<span class="org-builtin">:var-decl</span>  (<span class="org-builtin">:type</span>
             <span class="org-builtin">:identifier</span>
             (<span class="org-builtin">:maybe</span> (<span class="org-builtin">:symbol</span> <span class="org-string">"="</span>)
                     <span class="org-builtin">:integer-constant</span>)
             (<span class="org-builtin">:symbol</span> <span class="org-string">";"</span>)))

(<span class="org-builtin">:type</span>      ((<span class="org-builtin">:or</span> (<span class="org-builtin">:keyword</span> <span class="org-string">"int"</span>)
                  (<span class="org-builtin">:keyword</span> <span class="org-string">"char"</span>)
                  (<span class="org-builtin">:keyword</span> <span class="org-string">"bool"</span>))))

(<span class="org-builtin">:var-decls</span> ((<span class="org-builtin">:many</span> <span class="org-builtin">:var-decl</span>)))
</pre>
</div>
<p>
The example outlined in Figure <a href="#org361c76f">4</a> is by no means
practical, since there are more sophisticated ways of matching a
variable declaration, but it should be enough for a brief
explanation. Additionally, the obligatory <code>:SYMBOL</code> and <code>:KEYWORD</code> rules
were omitted, as they are potentially implied by context.
</p>

<p>
Suppose that the compiler reads a file which may contain many variable
declarations, as exemplified in Figure <a href="#org4c3e72f">5</a>. We begin by
attempting to match the rule <code>:VAR-DECLS</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Example of a potential input file for the matching engine.</label><pre class="src src-fundamental" id="org4c3e72f">int   foo        = 5;
char  downcase_a = 97;
bool  false_val  = 0;
float this_fails = 3;
</pre>
</div>
<p>
The file will fail a match for a <code>:VAR-DECL</code> in line 4, since the <code>:TYPE</code>
rule will not match the keyword <code>"float"</code>. It will, however, not fail
the entirety of the match process, giving the results of the first
three lines. This happens due to the <code>:MANY</code> quantifier.
</p>

<p>
Since this quantifier is enclosed in a <i>precise match</i> context, in the
definition of <code>:VAR-DECLS</code>, if no <code>:VAR-DECL</code> were matched, the whole
match process would fail, and raise a condition in the matching
engine.
</p>

<p>
For the example given at Figure <a href="#org4c3e72f">5</a>, the match process would
not fail with a syntax error. This is an undesided grammar runtime
bug. The programmer could mitigate this problem with a <i>terminal</i> after
the quantified variable declarations.
</p>
</div>
</div>

<div id="outline-container-org7a5bee7" class="outline-2">
<h2 id="org7a5bee7"><span class="section-number-2">5</span> Conclusion</h2>
<div class="outline-text-2" id="text-5">
<p>
Grammar engines are certainly of great interest when designing a
language, and so they often shape the way languages work to ensure
that the syntax analysis of said language can be done by such a
engine. They also yield seemingly simple structures when implemented,
which guarantees easier debugging.
</p>

<p>
The time I spent building the matching engine was satisfactory, and
ended up producing the discussed grammar language due to the way my
compiler's syntax analysis was designed. The language was first though
on paper, then carefully modified so that a comprehensive matcher
could operate on it.
</p>

<p>
The matching engine itself is comprised of two relevant parts: a
tokenizer and a matcher, which were not discussed in this article. But
they were implemented as layers of software, such that the tokenizer
was a foundation for matching the built-in rules and specific text
strings; the matcher was the middle layer which could interpret the
grammar language, and then the language itself comes on top.
</p>

<p>
This structure ended up being very interesting, because the software
itself is now robust, and not necessarily specific to the Jack
programming language. Further exploration can be made to make it work
with other languages, and maybe even to analyze itself. I intend to
soon attempt to build a Lisp dialect by just swapping the rule set of
this matching engine. Performing this new experiment would lay the
foundation to one of my future projects.
</p>



<p>
<a id="org2a86e85"></a>
</p>

<p>

<h1 class='org-ref-bib-h1'>Bibliography</h1>
<ul class='org-ref-bib'><li><a id="nand2tetris">[nand2tetris]</a> <a name="nand2tetris"></a>"Noam Nisan & Shimon Schocken", The Elements of Computing Systems, MIT Press (2008).</li>
<li><a id="sicp">[sicp]</a> <a name="sicp"></a>"Harold Abelson, Gerald Jay Sussman & Julie Sussman", Structure and Interpretation of Computer Programs, MIT Press (1996).</li>
<li><a id="newton2006">[newton2006]</a> <a name="newton2006"></a>"Newton José Vieira", Introdução aos Fundamentos da Computação, Cengage Learning (2006).</li>
</ul>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/luksamuk/cl-jackc">https://github.com/luksamuk/cl-jackc</a> 
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
The compiler is actually built in more than two projects, as
the rest of the toolchain (Assembler and VM Translator) is built in
chapters prior to the compiler-related chapters.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
This choice was made due to Common Lisp's structure regarding
<i>packages</i>, which are analogous to C libraries in some ways. A Lisp
<code>KEYWORD</code> is agnostic to context, as it belongs to its own package,
whereas the next obvious choice (a Lisp <code>SYMBOL</code>) is not.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
For better understanding, the word <i>namespace</i> was used, though
not technically correct.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
This is mostly an arbitrary choice, and the comments may be
easily incorporated in the grammar. However, comments should not
relate to grammatical rules themselves.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Lucas Vieira</p>
<p class="email">Email: <a href="mailto:lucasvieira@protonmail.com">lucasvieira@protonmail.com</a></p>
<p class="date">Created: 2019-05-07 ter 21:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
