#+TITLE: ~cl-jackc~'s Grammar Language
#+AUTHOR: Lucas Vieira
#+EMAIL: lucasvieira@protonmail.com
#+LATEX_CLASS_OPTIONS: [a4paper,11pt,oneside]
#+LaTeX_HEADER: \usepackage{lmodern}
#+LaTeX_HEADER: \usepackage{microtype}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \hypersetup{colorlinks, citecolor=black, filecolor=black, linkcolor=black, urlcolor=black}
#+OPTIONS: toc:nil num:1 email:t

\begin{center}
\textit{ABSTRACT}
\end{center}

\par\noindent
~cl-jackc~ is an implementation of a compiler for the Jack programming
language. It uses its own $LL(1)$ grammar engine, written from scratch
in Common Lisp. This article outlines the domain-specific language
for specifying grammar rules, its key points, and my experience
on building the matching engine which interprets the grammar
language.


* Introduction

# Brief project introduction and motivation.
# Discuss the three key points on sicp.
Building programming languages are often an arduous, but fun task. Some
of the work lies on the designing of the language and its syntactical
elements /per se/. The rest of the work lies on building the tools
to make the language work, namely the compiler toolchain. In this
article, I discuss a fragment of the compiler toolchain for the Jack
programming language, one of the projects proposed in ~[Nisan08]~, which
is the parser for the syntax analysis of the Jack programming language.

The book provides a very clear grammar for Jack, and so the job of the
reader is to simply write a compiler for the language, in two
different projects[fn:4]. Here I outline some of my strategies to build such
an ambitious project, and how I dealt with it, while having zero
experience.

As per direct influence of ~[Abe96]~, I did not view the compiler
architecture as a rigid hierarchy of software modules which
interact with each other. While the modularized approach is still
maintained, especially for organization purposes, most of the syntax
analyzer was written as layers of software comprising of certain
abstractions, as if each of these layers were languages themselves
that could be used to build upper abstraction layers.

This approach led me into building a specific language to represent
the grammar of the Jack programming language in the topmost level. It
also acquired the intended effect of having an underlying robust,
simple and well-organized codebase. The details and operation of this
topmost grammar language are detailed as follows.

* Grammar syntax

The compiler's grammar language is written using s-expressions, since
the application itself is written in Common Lisp. The chosen language
provides powerful abstractions for dealing with lists. Since the
grammar itself is written as an abstract syntax tree, Lisp makes it
easier to traverse each rule.

A grammar is a list of rules. Each rule is a pair of two elements: a
/name/ and a /match/. There must be at least one rule enumerating
/terminals/, which are expected textual elements.

/Names/ are Lisp keywords[fn:2], and therefore are prepended with a
double colon (~:)~, so that they are agnostic to the namespace[fn:1]
they're in.

Figure [[fig:class_rule]] is a transcribed fragment of a single rule
for matching with a class structure of the Jack programming
language. The rule is provided for illustrative purposes.

#+name: fig:class_rule
#+label: fig:class_rule
#+caption: Rule for matching a class definition in the Jack language.
#+begin_src lisp
(:class   ((:keyword "class") :class-name (:symbol "{")
           (:many :class-var-dec)
           (:many :subroutine-dec)
           (:symbol "}")))
#+end_src
\hfill \break

The /match/ component of a rule is, in itself, a list, and so it carries
its own meaning. The /match/ may be populated by other /keyword names/,
/quantified rules/, /precise rules/ and /exact-matches/, which must also be
specified in the grammar itself.

The previous code snippet offers a way to expect a class definition in
the Jack programming language ~[Nisan08]~. To recognize a class, the
grammar expects the match of a /precise/ pattern, in the following
order:

- An exact match with the keyword ~class~;
- The class's name, whatever it may be;
- An exact match with the symbol ~{~;
- Zero or more variable declarations, whatever it may be;
- Zero or more subroutine declarations, whatever it may be;
- An exact match with the symbol ~}~.

These operations (as well as the /match/ portion of the rule itself)
require better clarification of their underlying structure.

** Atomic rules

A rule is atomic if it is comprised of a single keyword. These rules
are of the same type of the rule /names/, as they are meant to be
replaced by the body of another rule by the matching engine.

There are also built-in atomic rules which do not need to appear on
the grammar, since they are primitive to the matching engine, and so
they are enumerated as follows:

- ~:IDENTIFIER~: Any name which does not start with a letter. Breaks
  before a ~:SYMBOL~ or any whitespace.
- ~:STRING-CONSTANT~: Any text surrounded with quotes. Cannot have any
  line breaks.
- ~:INTEGER-CONSTANT~: Any text comprised only of numbers and no
  ~:SYMBOL~ terminals.
- /Terminals/: Any text. The text can be written as a string constant
  for Lisp.

Since matching these rules require knowledge of what a ~:SYMBOL~ and a
~:KEYWORD~ are, these rules must always be defined for any grammar. This
aspect will be discussed later, in greater detail.

In a rule such as ~(:KEYWORD "class")~, the element ~"class"~ is a
/terminal/, as it is raw text expected to be at the matching source code
position. However, the rule as a whole is not atomic, as will be
further discussed in the following subsection.

** Compound rules

Any list in the /match/ element is a compound rule. Since the /match/
element itself is a list comprised of several sub-rules, it is also
considered as a compound rule, in accordance to one of the following
archetypes.

*** Quantified rules

A /compound rule/ is a /quantified rule/ when its first element is a
quantifier keyword. The quantifier changes the matching engine context
for the elements it encloses, following the meaning of the quantifier
keywords:

- ~:OR~: A disjunction of rules. Attempts to match, in order, each of
  the sub-rules it encloses. Stops when one of the rules is matched,
  and does not check for the remaining rules.
- ~:MAYBE~: Attempts to sequentially match the group of all enclosed
  sub-rules, but the matching is optional; failure on the matching
  process does not fail the rest of the grammar match (/zero-or-one/).
- ~:MANY~: Attempts to match the group of all enclosed sub-rules
  exhaustively, and keeps collecting the matching results until the
  match fails (/zero-or-more/).

A /quantified rule/ such as =(:many :identifier)=, for example, will keep
collecting identifiers until there are no more identifiers to be
collected. When matching an identifier fails, then all previously
matched identifiers are collected. If no identifier was matched, the
match results in a neutral value, but not on failure.

A rule such as ~(:maybe :identifier :integer-constant)~ will attempt to
match an identifier and then an integer constant. If any of those
structures are not matched, then the match results in a neutral
value, but not on failure.

The rule ~(:or :identifier :integer-constant)~ attempts to match an
identifier. If the identifier is not found, it attempts to match an
integer constant. If the integer constant is also not found, then the
match results in failure.

*** Exact-matches

A /compound rule/ is an /exact-match rule/ when comprised of two elements,
where its first element is an existing rule in the grammar, and the
second element is an expected /terminal/.

The /terminal/ element of an /exact-match rule/ must belong to a
disjunctively-quantified rule, where each element of the disjunction
is a /terminal/ text as well. This rule is not supposed to be used in
matching time, though it is important for grammar verification.

Any /exact-match rule/ which uses a non-existing disjunctive rule, or
uses a /terminal/ which does not belong to the associated disjunctive
rule, is considered to be syntactically incorrect.

A rule such as ~(:KEYWORD "class")~ is a well-defined /exact-match rule/,
if and only if the grammar contains a rule as exemplified in Figure
[[fig:keyword_rule_example]].

#+name: fig_keyword_rule_example
#+label: fig:keyword_rule_example
#+caption: Example of a supporting rule for an /exact-match rule/.
#+begin_src lisp
(:KEYWORD   ((:OR "class" "constructor" "function" ...)))
#+end_src

*** Precise rules

A /precise rule/ is the commonest type of rule, as the /match/
element of a rule definition often falls into it. Moreover, any
non-disjunctively quantified rule ends up degenerating into a /precise
rule/, only changing the context where such /precise rule/ fails.

Any part of a /match/ element of a rule, which is also /compound/, but
does not fall into the previous categories, is a /precise rule/. In
other words, such rules are surrounded by parenthesis, but their first
element are not quantifiers, and they do not fit the /exact-match rule/
specification.

These /compound rules/ are basically enclosings for sub-rules which must
"travel" as a group, and so all of their sub-rules must always
match. Since a rule definition enumerates how it works, it is advised
that any /match/ portion of a rule definition should be a /precise rule/
itself.

A rule such as ~(:IDENTIFIER (:SYMBOL "=") :INTEGER-CONSTANT)~ is a
valid /precise rule/. The grammar expects three sub-rules to be matched
sequentially. Should any of them fail, then the whole group fails.

** Obligatory rules

As the matching engine was implemented, it was discovered that the
structure needed to assume that certain rules were to be
always expected. These obligatory rules, however, are lexical elements
which are common to most languages.

- ~:KEYWORD~: A disjunctively-quantified rule enumerating all text
  /terminals/ of the language which are /language keywords/.
- ~:SYMBOL~: A disjunctively-quantified rule enumerationg all text
  /terminals/ of the language which are /language symbols/.

Figure [[fig:jack_obligatory]] shows a snippet showing the Jack language's
keywords and symbols, based on the language's grammar specification
~[Nisan08, pp. 208-209]~.

#+name: fig:jack_obligatory
#+label: fig:jack_obligatory
#+caption: Keywords and symbols as defined for the Jack language.
#+begin_src lisp
(:keyword  ((:or "class" "constructor" "function"
                 "method" "field" "static" "var"
                 "int" "char" "boolean" "void"
                 "true" "false" "null" "this" "let"
                 "do" "if" "else" "while" "return")))

(:symbol   ((:or "{" "}" "(" ")" "[" "]" "." ","
                 ";" "+" "-" "*" "/" "&" "|" "<"
                 ">" "=" "~")))
#+end_src

** Code comments

Comments in any language are often surrounded by two tokens, which are
equivalent to text /terminals/. Comment detection, however, is not
considered part of the grammar rules, as they are treated as a
responsibility of the tokenizer.

The matching engine's topmost structure is responsible for comparing
tokens which are already assumed to be valid, and comment delimiters
(plus the contents of any comment) are not supposed to be valid
tokens. For that reason, the comments are defined using an outside
structure, a list of pairs which enumerate the tokens which enclose
any comments[fn:3].

Let us take the Jack programming language as an example, as the
matching engine was primarily built for it. A pair, in Lisp notation,
such as =("/*" . "*/")= shows that there may be comments in the source
file, which begin with the token =/*= and end with the token =*/=. And
so, the matching engine's head, which is supposed to point at every
read character, will simply skip the undesired characters -- both the
comment tokens and the text inbetween.

As for comments which end at a line break, a simple definition such as
=("//")= suffices. This definition can also be written in the form
=("//" . NIL)=, and so it implies that, when an end-of-comment delimiter
is not informed, then that delimiter must be a =#\Newline= character.

* Rule composition

The grammar language fundamentals have been outlined. /Terminals/,
/exact-matches/ and /built-in rules/ act as primitives, while other
/compound rules/ act as means of combination. At this point it is
important to discuss its /means of abstraction/ of the language.

Abstraction implies the building of structures which would allow the
creation of the /rules/ themselves. Figure [[fig:class_rule]] already hints
at what is possible to make of such language. As a better example, we
should take a simpler example, as described in Figure [[fig:var_example]].

#+name: fig:var_example
#+label: fig:var_example
#+caption: Rule example for matching a variable declaration.
#+begin_src lisp
(:var-decl  (:type
             :identifier
             (:maybe (:symbol "=")
                     :integer-constant)
             (:symbol ";")))

(:type      ((:or (:keyword "int")
                  (:keyword "char")
                  (:keyword "bool"))))

(:var-decls ((:many :var-decl)))
#+end_src
\hfill \break

The example outlined in [[fig:var_example]] is by no means practical,
since there are more sophisticated ways of matching a variable
declaration, but it should be enough for a brief
explanation. Additionally, the obligatory ~:SYMBOL~ and ~:KEYWORD~ rules
were omitted, as they are potentially implied by context.

Suppose that the compiler reads a file which may contain many variable
declarations, as exemplified in Figure [[fig:var_file]]. We begin by
attempting to match the rule ~:VAR-DECLS~.

#+name: fig:var_file
#+label: fig:var_file
#+caption: Example of a potential input file for the matching engine.
#+begin_src fundamental
int   foo        = 5;
char  downcase_a = 97;
bool  false_val  = 0;
float this_fails = 3;
#+end_src
\hfill \break

The file will fail a match for a ~:VAR-DECL~ in line 4, since the ~:TYPE~
rule will not match the keyword ~"float"~. It will, however, not fail
entirely, giving the results of the first three lines, due to the
~:MANY~ quantifier. This could be considered an unwanted grammar runtime
bug, which could be fixed through a careful redefinition of grammar
rules.

* Conclusion

$LL(1)$ grammars are certainly of great interest when designing a
language, and so they often shape the way languages work to ensure
that the syntax analysis of said language can be done by such a
grammar. They are also seemingly simple to implement, which guaratees
easier debugging.

The time I spent building the matching engine was satisfactory, and
ended up producing the discussed grammar language due to the way my
compiler's syntax analysis was designed. The language was first though
on paper, then carefully modified so that a comprehensive matcher
could operate on it.

The matching engine itself is comprised of two relevant parts: a
tokenizer and a matcher, which were not discussed in this article. But
they were implemented as layers of software, such that the tokenizer
was a foundation for matching the built-in rules and specific text
strings; the matcher was the middle layer which could interpret the
grammar language, and then the language itself comes on top.

This structure ended up being very interesting, because the software
itself is now robust, and not necessarily specific to the Jack
programming language. Further exploration can be made to make it work
with other languages. I will soon attempt to build a Lisp dialect by
just swapping the rule set of the Jack compiler. Performing this new
experiment would lay the foundation to a future project.

* References

\par \noindent
~[Abe96]~ Abelson, H.; Sussman, G. J.; Sussman, J.. /"Structure and
Interpretation of Computer Programs"/. MIT Press, 1996.
\newline
\par \noindent
~[Nisan08]~ Nisan, N.; Schocken, S.. /"The Elements of Computing
Systems: Building a Modern Computer from First Principles"/. MIT
Press, 2008.

* Footnotes

[fn:4] The compiler is actually built in more than two projects, as
the rest of the toolchain (Assembler and VM Translator) is built in
chapters prior to the compiler-related chapters.

[fn:3] This is mostly an arbitrary choice, and the comments may be
easily incorporated in the grammar. However, comments should not
relate to grammatical rules themselves.

[fn:2] This choice was made due to Common Lisp's structure regarding
/packages/, which are analogous to C libraries in some ways. A Lisp
~KEYWORD~ is agnostic to context, as it belongs to its own package,
whereas the next obvious choice (a Lisp ~SYMBOL~) is not.

[fn:1]  For better understanding, the word /namespace/ was used, though
not technically correct.
